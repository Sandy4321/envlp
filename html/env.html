
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>env</title>
      <meta name="generator" content="MATLAB 7.8">
      <meta name="date" content="2012-03-05">
      <meta name="m-file" content="env"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>env</h1>
         <!--introduction-->
         <p>Fit the envelope model.</p>
         <!--/introduction-->
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Usage</a></li>
               <li><a href="#2">Description</a></li>
               <li><a href="#3">References</a></li>
            </ul>
         </div>
         <h2>Usage<a name="1"></a></h2>
         <p>stat=env(X,Y,u)</p>
         <p>Input</p>
         <div>
            <ul>
               <li>X: Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete
                  or continuous.
               </li>
               <li>Y: Multivariate responses. An n by r matrix, r is the number of responses and n is number of observations. The responses must
                  be continuous variables.
               </li>
               <li>u: Dimension of the envelope. An integer between 0 and r.</li>
            </ul>
         </div>
         <p>Output</p>
         <p>stat: A list that contains the maximum likelihood estimators and some statistics.</p>
         <div>
            <ul>
               <li>stat.beta: The envelope estimator of the regression coefficients <img src="env_eq83200.png" alt="$$\beta$">. An r by p matrix.
               </li>
               <li>stat.Sigma: The envelope estimator of the error covariance matrix.  An r by r matrix.</li>
               <li>stat.Gamma: The orthogonal basis of the envelope subspace. An r by u semi-orthogonal matrix.</li>
               <li>stat.Gamma0: The orthogonal basis of the complement of the envelope subspace.  An r by r-u semi-orthogonal matrix.</li>
               <li>stat.eta: The coordinates of <img src="env_eq83200.png" alt="$$\beta$"> with respect to Gamma. An u by p matrix.
               </li>
               <li>stat.Omega: The coordinates of Sigma with respect to Gamma. An u by u matrix.</li>
               <li>stat.Omega0: The coordinates of Sigma with respect to Gamma0. An r-u by r-u matrix.</li>
               <li>stat.alpha: The estimated intercept in the envelope model.  An r by 1 vector.</li>
               <li>stat.l: The maximized log likelihood function.  A real number.</li>
               <li>stat.ratio: The asymptotic standard error ratio of the stanard multivariate linear regression estimator over the envelope
                  estimator, for each element in <img src="env_eq83200.png" alt="$$\beta$">.  An r by p matrix.
               </li>
               <li>stat.np: The number of parameters in the envelope model.  A positive integer.</li>
            </ul>
         </div>
         <h2>Description<a name="2"></a></h2>
         <p>This function fits the envelope model to the responses and predictors, using the maximum likehood estimation.  When the dimension
            of the envelope is between 1 and r-1, we implemented the algorithm in Cook et al. (2010).  When the dimension is r, then the
            envelope model degenerates to the standard multivariate linear regression.  When the dimension is 0, it means that X and Y
            are uncorrelated, and the fitting is different.
         </p>
         <h2>References<a name="3"></a></h2>
         <div>
            <ul>
               <li>The codes is implemented based on the algorithm in Section 4.3 of Cook et al (2010).</li>
               <li>The Grassmann manifold optimization step calls the package sg_min 2.4.1 by Ross Lippert (<a href="http://web.mit.edu/~ripper/www.sgmin.html)">http://web.mit.edu/~ripper/www.sgmin.html)</a>.
               </li>
            </ul>
         </div>
         <p class="footer"><br>
            Published with MATLAB&reg; 7.8<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% env
% Fit the envelope model.

%% Usage
% stat=env(X,Y,u)
%
% Input
%
% * X: Predictors. An n by p matrix, p is the number of predictors. The
% predictors can be univariate or multivariate, discrete or continuous.
% * Y: Multivariate responses. An n by r matrix, r is the number of
% responses and n is number of observations. The responses must be 
% continuous variables.
% * u: Dimension of the envelope. An integer between 0 and r.
%
% Output
% 
% stat: A list that contains the maximum likelihood estimators and some
% statistics.
% 
% * stat.beta: The envelope estimator of the regression coefficients $$\beta$. 
% An r by p matrix.
% * stat.Sigma: The envelope estimator of the error covariance matrix.  An r by
% r matrix.
% * stat.Gamma: The orthogonal basis of the envelope subspace. An r by u
% semi-orthogonal matrix.
% * stat.Gamma0: The orthogonal basis of the complement of the envelope
% subspace.  An r by r-u semi-orthogonal matrix.
% * stat.eta: The coordinates of $$\beta$ with respect to Gamma. An u by p
% matrix.
% * stat.Omega: The coordinates of Sigma with respect to Gamma. An u by u
% matrix.
% * stat.Omega0: The coordinates of Sigma with respect to Gamma0. An r-u by r-u
% matrix.
% * stat.alpha: The estimated intercept in the envelope model.  An r by 1
% vector.
% * stat.l: The maximized log likelihood function.  A real number.
% * stat.ratio: The asymptotic standard error ratio of the stanard multivariate 
% linear regression estimator over the envelope estimator, for each element 
% in $$\beta$.  An r by p matrix.
% * stat.np: The number of parameters in the envelope model.  A positive
% integer.

%% Description
% This function fits the envelope model to the responses and predictors,
% using the maximum likehood estimation.  When the dimension of the
% envelope is between 1 and r-1, we implemented the algorithm in Cook et
% al. (2010).  When the dimension is r, then the envelope model degenerates
% to the standard multivariate linear regression.  When the dimension is 0,
% it means that X and Y are uncorrelated, and the fitting is different.

%% References
% 
% * The codes is implemented based on the algorithm in Section 4.3 of Cook 
% et al (2010).
% * The Grassmann manifold optimization step calls the package sg_min 2.4.1
% by Ross Lippert (http://web.mit.edu/~ripper/www.sgmin.html).


function stat=env(X,Y,u)


% To Yi: 1) We need to do check something, e.g., if Y is discrete, the model cannot
% handle that, but I do not know how to check that either.  There are some
% other checks: u must be an interger between 0 and r, X and Y must have
% the same length.


global sigY;
global sigres;

%REPLACE_WITH_DASH_DASH-preparationREPLACE_WITH_DASH_DASH-
[n p]=size(X);
r=size(Y,2);
XC=center(X);
YC=center(Y);

sigX=cov(X,1);
sigY=cov(Y,1);

[beta_OLS sigres]=fit_OLS(X,Y);
eigtem=eig(sigY);


% With different u, the model will be different.  When u=0, X and Y are
% uncorrelated, so it should be fitted differently.  When u=r, the envelope
% model reduces to the standard model, and it also should be fitted
% differently.


if u>0 && u<r


    %REPLACE_WITH_DASH_DASH-Compute \Gamma using sg_minREPLACE_WITH_DASH_DASH-

    init=startv(X,Y,u);
    [l Gamma]=sg_min(init,'prcg','quiet');


    %REPLACE_WITH_DASH_DASH-Compute the rest of the parameters based on \GammaREPLACE_WITH_DASH_DASH-
    Gamma0=grams(nulbasis(Gamma'));
    alpha=mean(Y)';
    beta=Gamma*Gamma'*beta_OLS;
    eta=Gamma'*beta;
    Omega=Gamma'*sigres*Gamma;
    Omega0=Gamma0'*sigY*Gamma0;
    Sigma1=Gamma*Omega*Gamma';
    Sigma2=Gamma0*Omega0*Gamma0';
    Sigma=Sigma1+Sigma2;

    %REPLACE_WITH_DASH_DASH-compute asymptotic variance and get the ratiosREPLACE_WITH_DASH_DASH-
    asyfm=kron(inv(cov(X,1)),Sigma);
    temp=kron(eta*sigX*eta',inv(Omega0))+kron(Omega,inv(Omega0))+kron(inv(Omega),Omega0)-2*kron(eye(u),eye(r-u));
    asyem=kron(inv(sigX),Sigma1)+kron(eta',Gamma0)*inv(temp)*kron(eta,Gamma0');
    stat.ratio=reshape(sqrt(diag(asyfm)./diag(asyem)),r,p);
    stat.beta=beta;
    stat.Gamma=Gamma;
    stat.Gamma0=Gamma0;
    stat.eta=eta;
    stat.Omega=Omega;
    stat.Omega0=Omega0;
    stat.alpha=alpha;
    stat.np=r+u*p+r*(r+1)/2;
    stat.l=-n*r/2*(1+log(2*pi))-n/2*(l+log(prod(eigtem(eigtem>0))));
    
elseif u==0
    
    
    
    stat.beta=zeros(r,p);
    stat.Gamma=[];
    stat.eta=[];
    stat.Omega=[];
    stat.Gamma0=eye(r);
    stat.Sigma=sigY;
    stat.Omega0=sigY;
    stat.alpha=mean(Y)';
    stat.l=-n*r/2*(1+log(2*pi))-n/2*log(prod(eigtem(eigtem>0)));
    stat.ratio=ones(r,p);
    stat.np=r+u*p+r*(r+1)/2;
    

elseif u==r
    
    
    stat.beta=beta_OLS;
    stat.eta=beta_OLS;
    stat.Sigma=sigres;
    stat.Gamma=eye(r);
    stat.Gamma0=[];
    stat.Omega=sigres;
    stat.Omega0=[];
    stat.alpha=mean(Y)';
    eigtem=eig(sigres);
    stat.l=-n*r/2*(1+log(2*pi))-n/2*log(prod(eigtem(eigtem>0)));
    stat.ratio=ones(r,p);
    stat.np=r+u*p+r*(r+1)/2;
    
end
    
    
    
##### SOURCE END #####
-->
   </body>
</html>